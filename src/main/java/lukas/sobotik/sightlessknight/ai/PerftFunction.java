package lukas.sobotik.sightlessknight.ai;

import lukas.sobotik.sightlessknight.gamelogic.Board;
import lukas.sobotik.sightlessknight.gamelogic.BoardLocation;
import lukas.sobotik.sightlessknight.gamelogic.FenUtils;
import lukas.sobotik.sightlessknight.gamelogic.GameState;
import lukas.sobotik.sightlessknight.gamelogic.Move;
import lukas.sobotik.sightlessknight.gamelogic.Piece;
import lukas.sobotik.sightlessknight.gamelogic.Rules;
import lukas.sobotik.sightlessknight.gamelogic.entity.PieceType;
import lukas.sobotik.sightlessknight.gamelogic.entity.Team;
import lukas.sobotik.sightlessknight.views.play.PlayView;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

public class PerftFunction {
    Board board;
    GameState gameState;
    PlayView view;
    /**
     * Constructs a PerftFunction object.
     *
     * @param board the Board object representing the current state of the chessboard
     * @param gameState the GameState object representing the current state of the game
     * @param view the PlayView object representing the view of the game
     */
    public PerftFunction(Board board, GameState gameState, PlayView view) {
        this.board = board;
        this.gameState = gameState;
        this.view = view;

        GameState.moveNumber = 0;
        GameState.capturedPieces = 0;
        GameState.enPassantCaptures = 0;
        GameState.enPassantCapturesReturned = 0;
    }

    /**
     * Returns all valid moves for a given team.
     * @param team team whose valid moves are to be returned.
     * @return list of all valid moves for the given team.
     */
    public List<Move> getAllValidMoves(Team team) {
        List<Move> validMoves = new ArrayList<>();
        for (int i = 0; i < 64; i++) {
            var piece = board.pieces[i];
            var location = board.getPointFromArrayIndex(i);
            if (piece == null || piece.team != team) continue;

            var allMoves = Rules.getValidMoves(board.getPointFromArrayIndex(i), piece, board, true);
            var moves = allMoves.stream().map(Move::getTo).toList();
            validMoves.addAll(new HashSet<>(moves).stream().map(moveLocation -> {
                Move move = new Move(location, moveLocation, piece, board.getPiece(moveLocation));
                // Pawn Promotion
                if (((moveLocation.getY() == 0 && piece.team == Team.BLACK) || (moveLocation.getY() == 7 && piece.team == Team.WHITE))
                        && piece.type == PieceType.PAWN) {
                    // Add four promotion options: bishop, knight, rook, queen
                    List<PieceType> promotionPieces = Arrays.asList(PieceType.BISHOP, PieceType.KNIGHT, PieceType.ROOK, PieceType.QUEEN);
                    for (PieceType promotionPiece : promotionPieces) {
                        Move promotionMove = new Move(location, moveLocation, piece, board.getPiece(moveLocation));
                        promotionMove.setPromotionPiece(promotionPiece);
                        if (promotionPiece == PieceType.QUEEN) return promotionMove;
                        validMoves.add(promotionMove);
                    }
                }
                // En Passant
                BoardLocation enPassantCapture = new BoardLocation(moveLocation.getX(), location.getY());
                if (board.getPiece(enPassantCapture) != null
                        && location.getX() != moveLocation.getX()) {
                    piece.enPassant = true;
                }
                return move;
            }).toList());
        }

        return validMoves;
    }

    /**
     * Main method for the Perft Function.
     * @param depth depth of the Perft Function.
     * @param turn Team whose turn it is.
     * @param log whether to log the results of the Perft Function.
     * @param debug whether to preform a resource intensive check that helps with debugging.
     * @return number of positions generated by the Perft Function.
     */
    public int playMoves(int depth, Team turn, boolean log, boolean debug) {
        if (depth == 0) return 1;

        var fenUtils = new FenUtils(gameState.board.pieces);
        String beforeFen = "", moveFen = "", afterFen = "";
        List<Move> moves = getAllValidMoves(turn);
        int numberOfPositions = 0;
        Map<String, Integer> numberOfPositionsOnMove = new HashMap<>();

        for (Move move : moves) {
            debugPause(numberOfPositions, move, depth);
            if (debug) beforeFen = fenUtils.generateFenFromPosition(gameState.getBoard().pieces, turn);
            gameState.playMove(move, true);
            if (debug) moveFen = fenUtils.generateFenFromPosition(gameState.getBoard().pieces, turn);

            int positions = playMoves(depth - 1, turn == Team.BLACK ? Team.WHITE : Team.BLACK, log, debug);
            numberOfPositions += positions;
            addPositionsToHashMap(move, numberOfPositionsOnMove, positions);
            debugPause(numberOfPositions, move, depth);

            gameState.undoMove(move);
            if (debug) {
                afterFen = fenUtils.generateFenFromPosition(gameState.getBoard().pieces, turn);
                debugCheck(beforeFen, moveFen, afterFen, fenUtils);
            }
        }

        if (log) {
            System.out.println("------------------------------------------");
            List<String> sortedKeys = new ArrayList<>(numberOfPositionsOnMove.keySet());
            Collections.sort(sortedKeys);
            for (String key : sortedKeys) {
                System.out.println(key + ": " + numberOfPositionsOnMove.get(key));
            }
        }

        return numberOfPositions;
    }

    /**
     * Method used only for logging the split results of the Perft function.
     * @param move move that was played.
     * @param numberOfPositionsOnMove map that stores the split results of the Perft function.
     * @param positions number of positions generated by the Perft Function.
     */
    private static void addPositionsToHashMap(final Move move, final Map<String, Integer> numberOfPositionsOnMove, final int positions) {
        if (move.getPromotionPiece() != null) {
            numberOfPositionsOnMove.put(move.getFrom().getAlgebraicNotationLocation()
                            + move.getTo().getAlgebraicNotationLocation()
                            + new FenUtils(new Piece[64]).getSymbolFromPieceType(move.getPromotionPiece(), Team.BLACK), positions);
        } else {
            numberOfPositionsOnMove.put(move.getFrom().getAlgebraicNotationLocation()
                                                + move.getTo().getAlgebraicNotationLocation(), positions);
        }
    }

    /**
     * Method used for debugging.
     * It preforms a check on the FENs before and after the move.
     * This method is resource intensive and should not be used in production.
     * @param beforeFen FEN generated before the move occurs
     * @param moveFen   FEN generated after the move occurs
     * @param afterFen  FEN generated after the move is undone
     * @param fenUtils  FenUtils object used to generate the FENs
     */
    private void debugCheck(String beforeFen, String moveFen, String afterFen, FenUtils fenUtils) {
        if (!beforeFen.equals(afterFen)) {
            System.out.println("---");
            System.out.println("--- From ---");
            gameState.getBoard().printBoardInConsole(true, fenUtils.generatePositionFromFEN(beforeFen));
            System.out.println("--- To ---");
            gameState.getBoard().printBoardInConsole(true, fenUtils.generatePositionFromFEN(moveFen));
            System.out.println("--- After ---");
            gameState.getBoard().printBoardInConsole(true, fenUtils.generatePositionFromFEN(afterFen));
            System.out.println("---");
            sleep(9000);
        }
    }

    /**
     * Helpful method for debugging used for pausing the Perft Function on certain conditions.
     * @param numberOfPositions number of positions for the Perft Function generated so far
     * @param move what move the Perft Function is currently processing
     */
    private void debugPause(int numberOfPositions, Move move, int depth) {
        boolean pause = false;

        if (pause && view != null) {
            view.getUI().ifPresent(value -> value.access(() -> view.createBoard(board.pieces)));
            view.getUI().ifPresent(value -> value.access(() -> view.showTargetSquare(String.valueOf(GameState.moveNumber))));
            board.printBoardInConsole(true);
            sleep();
        } else if (pause) {
            System.out.println("-------------------");
            System.out.println(numberOfPositions + " - " + move.getFrom().getAlgebraicNotationLocation() + move.getTo().getAlgebraicNotationLocation());
            if (move.getFrom() == move.getTo()) System.out.println("EXPECTED ERROR");
            board.printBoardInConsole(true);
            sleep();
        }
    }

    /**
     * Method that pauses code execution for 3 seconds.
     */
    private void sleep() {
        sleep(3000);
    }

    /**
     * Method that pauses code execution for a given number of milliseconds.
     * @param millis number of milliseconds to pause code execution for
     */
    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
