package lukas.sobotik.sightlessknight.ai;

import lukas.sobotik.sightlessknight.gamelogic.Board;
import lukas.sobotik.sightlessknight.gamelogic.FenUtils;
import lukas.sobotik.sightlessknight.gamelogic.GameState;
import lukas.sobotik.sightlessknight.gamelogic.Move;
import lukas.sobotik.sightlessknight.gamelogic.Piece;
import lukas.sobotik.sightlessknight.gamelogic.Rules;
import lukas.sobotik.sightlessknight.gamelogic.entity.Team;
import lukas.sobotik.sightlessknight.views.play.PlayView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PerftFunction {
    Board board;
    GameState gameState;
    PlayView view;
    /**
     * Constructs a PerftFunction object.
     *
     * @param board the Board object representing the current state of the chessboard
     * @param gameState the GameState object representing the current state of the game
     * @param view the PlayView object representing the view of the game
     */
    public PerftFunction(Board board, GameState gameState, PlayView view) {
        this.board = board;
        this.gameState = gameState;
        this.view = view;

        GameState.moveNumber = 0;
        GameState.enPassantCaptures = 0;
    }

    /**
     * Main method for the Perft Function.
     * @param depth depth of the Perft Function.
     * @param turn Team whose turn it is.
     * @param log whether to log the results of the Perft Function.
     * @param debug whether to preform a resource intensive check that helps with debugging.
     * @return number of positions generated by the Perft Function.
     */
    public double playMoves(int depth, Team turn, boolean log, boolean debug, boolean isFirstCall) {
        if (depth == 0) return 1;

        var fenUtils = new FenUtils(gameState.board.pieces);
        String beforeFen = "", moveFen = "", afterFen = "";
        List<Move> moves = Rules.getAllValidMovesForTeam(turn, gameState.board, true);
        double numberOfPositions = 0;
        Map<String, Double> numberOfPositionsOnMove = new HashMap<>();

        for (Move move : moves) {
            debugPause(numberOfPositions, move, depth);
            if (debug) beforeFen = fenUtils.generateFenFromPosition(gameState.getBoard().pieces, turn);
            gameState.playMove(move, true);

            double positions = playMoves(depth - 1, turn == Team.BLACK ? Team.WHITE : Team.BLACK, log, debug, false);
            numberOfPositions += positions;
            addPositionsToHashMap(move, numberOfPositionsOnMove, positions);
            debugPause(numberOfPositions, move, depth);

            gameState.undoMove(move);

            if (debug) {
                afterFen = fenUtils.generateFenFromPosition(gameState.getBoard().pieces, turn);
                debugCheck(beforeFen, moveFen, afterFen, fenUtils);
            }
        }

        if (log && isFirstCall) {
            System.out.println("------------------------------------------");
            List<String> sortedKeys = new ArrayList<>(numberOfPositionsOnMove.keySet());
            Collections.sort(sortedKeys);
            for (String key : sortedKeys) {
                System.out.println(key + ": " + numberOfPositionsOnMove.get(key));
            }
        }

        return numberOfPositions;
    }

    /**
     * Method used only for logging the split results of the Perft function.
     * @param move move that was played.
     * @param numberOfPositionsOnMove map that stores the split results of the Perft function.
     * @param positions number of positions generated by the Perft Function.
     */
    private static void addPositionsToHashMap(final Move move, final Map<String, Double> numberOfPositionsOnMove, final double positions) {
        if (move.getPromotionPiece() != null) {
            numberOfPositionsOnMove.put(move.getFrom().getAlgebraicNotationLocation()
                            + move.getTo().getAlgebraicNotationLocation()
                            + new FenUtils(new Piece[64]).getSymbolFromPieceType(move.getPromotionPiece(), Team.BLACK), positions);
        } else {
            numberOfPositionsOnMove.put(move.getFrom().getAlgebraicNotationLocation()
                                                + move.getTo().getAlgebraicNotationLocation(), positions);
        }
    }

    /**
     * Method used for debugging.
     * It preforms a check on the FENs before and after the move.
     * This method is resource intensive and should not be used in production.
     * @param beforeFen FEN generated before the move occurs
     * @param moveFen   FEN generated after the move occurs
     * @param afterFen  FEN generated after the move is undone
     * @param fenUtils  FenUtils object used to generate the FENs
     */
    private void debugCheck(String beforeFen, String moveFen, String afterFen, FenUtils fenUtils) {
        if (!beforeFen.equals(afterFen)) {
            System.out.println("---");
            System.out.println("--- From ---");
            gameState.getBoard().printBoardInConsole(true, fenUtils.generatePositionFromFEN(beforeFen));
            System.out.println("--- To ---");
            gameState.getBoard().printBoardInConsole(true, fenUtils.generatePositionFromFEN(moveFen));
            System.out.println("--- After ---");
            gameState.getBoard().printBoardInConsole(true, fenUtils.generatePositionFromFEN(afterFen));
            System.out.println("---");
            sleep(9000);
        }
    }

    /**
     * Helpful method for debugging used for pausing the Perft Function on certain conditions.
     * @param numberOfPositions number of positions for the Perft Function generated so far
     * @param move what move the Perft Function is currently processing
     */
    private void debugPause(double numberOfPositions, Move move, int depth) {
        boolean pause = false;

//        if (move.getMovedPiece().type == PieceType.PAWN) pause = true;

        if (pause && view != null) {
            view.getUI().ifPresent(ui -> ui.access(() -> {
                view.createBoard(board.pieces);
                view.showTargetSquare(String.valueOf(numberOfPositions));
                view.playMove(move);
                view.showBoard(false);
            }));
            board.printBoardInConsole(true);
            sleep();
        } else if (pause) {
            System.out.println("-------------------");
            System.out.println(numberOfPositions + " - " + move.getFrom().getAlgebraicNotationLocation() + move.getTo().getAlgebraicNotationLocation());
            if (move.getFrom() == move.getTo()) System.out.println("EXPECTED ERROR");
            board.printBoardInConsole(true);
//            board.bitboard.printBitboard();
            sleep();
        }
    }

    /**
     * Method that pauses code execution for 3 seconds.
     */
    private void sleep() {
        sleep(3000);
    }

    /**
     * Method that pauses code execution for a given number of milliseconds.
     * @param millis number of milliseconds to pause code execution for
     */
    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
